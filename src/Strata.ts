/**
 * @class OAuthWindow - A wrapper around a popup window that handles OAuth flow window management
 * @internal
 */
class OAuthWindow {
  private window: Window;

  constructor({ window }: { window: Window }) {
    this.window = window;
  }

  /**
   * Calculates the optimal position and dimensions for the popup window
   * @param width - Desired width of the popup
   * @param height - Desired height of the popup
   * @returns Object containing the calculated position and dimensions
   */
  static getLayout({ width, height }: { width: number; height: number }): {
    top: number;
    left: number;
    width: number;
    height: number;
  } {
    const left = window.screenX + (window.outerWidth - width) / 2;
    const top = window.screenY + (window.outerHeight - height) / 2;
    return { left, top, width, height };
  }

  /**
   * Checks if the popup window is currently open
   * @returns true if the window is open, false otherwise
   */
  public isOpen(): boolean {
    return !!this.window && !this.window.closed;
  }

  /**
   * Closes the popup window if it's open
   */
  public close(): void {
    if (this.isOpen()) {
      this.window.close();
    }
  }
}

/**
 * @enum ConnectApiErrorCode - Error codes returned by the Connect API
 */
export enum ConnectApiErrorCode {
  /** Fallback error code when the specific error is not recognized */
  AuthorizationFailed = "AuthorizationFailed",
  /** The JWT token has expired and is no longer valid */
  ExpiredToken = "ExpiredToken",
  /** Internal server error occurred */
  InternalServerError = "InternalServerError",
  /** The provided Project ID is invalid or missing */
  InvalidProjectId = "InvalidProjectId",
  /** The provided Service Provider ID is invalid or missing */
  InvalidServiceProviderId = "InvalidServiceProviderId",
  /** The JWT signature verification failed */
  InvalidSignature = "InvalidSignature",
  /** The provided JWT token is invalid. This is a fallback for JWT related errors, ideally a more specific error code should be returned. */
  InvalidToken = "InvalidToken",
  /** Error occurred while fetching or processing JSON Web Keys */
  JwkError = "JwkError",
  /** The JWT token is malformed and cannot be parsed */
  MalformedToken = "MalformedToken",
  /** Authentication credentials are missing from the request */
  MissingAuth = "MissingAuth",
  /** Required claim is missing from the JWT token */
  MissingClaim = "MissingClaim",
  /** Authorization code is missing from the callback URL */
  MissingCode = "MissingCode",
  /** JWT token is missing the expiration claim */
  MissingExpiration = "MissingExpiration",
  /** State parameter is missing from the callback URL */
  MissingState = "MissingState",
  /** JWT token is missing from the request */
  MissingToken = "MissingToken",
  /** No signing keys available to verify the JWT signature */
  NoSigningKeys = "NoSigningKeys",
  /** The JWT token is not yet valid (nbf claim is in the future) */
  NotYetValid = "NotYetValid",
  /** User's session has expired. Retrying usually resolves this error. */
  SessionExpired = "SessionExpired",
  /** User's session was not found. Retrying usually resolves this error. */
  SessionNotFound = "SessionNotFound",
  /** The JWT signing algorithm does not match the expected algorithm */
  WrongAlgorithm = "WrongAlgorithm",
}

/**
 * @enum SdkErrorCode - Error codes generated by the SDK
 */
export enum SdkErrorCode {
  /** The provided Connect API host URL is invalid */
  InvalidConnectApiHost = "InvalidConnectApiHost",
  /** The provided authentication parameters are invalid */
  InvalidAuthParams = "InvalidAuthParams",
  /** The browser blocked the auth window */
  PopupBlocked = "PopupBlocked",
  /** The user closed the auth window before completing the flow */
  PopupClosed = "PopupClosed",
  /** The user did not complete the auth flow within the timeout period */
  AuthFlowTimeout = "AuthFlowTimeout",
}

/**
 * @type StrataErrorCode - Union type of all error codes
 */
export type StrataErrorCode = ConnectApiErrorCode | SdkErrorCode;

/**
 * @interface OAuthResultSuccess - Successful authorization result containing the connection ID
 */
interface OAuthResultSuccess {
  status: "Success";
  connectionId: string;
}

/**
 * @interface OAuthResultError - Failed authorization result containing an error code
 */
interface OAuthResultError {
  status: "Error";
  code: StrataErrorCode;
}

/**
 * @type OAuthResult - Discriminated union of authorization results
 */
type OAuthResult = OAuthResultSuccess | OAuthResultError;

/**
 * @class StrataError - Errors thrown by the SDK
 * @extends Error
 */
export class StrataError extends Error {
  /** The specific error code associated with this error */
  code: StrataErrorCode;

  /**
   * Creates a new StrataError
   * @param message - Human readable error message
   * @param code - Specific error code from StrataErrorCode type
   */
  constructor(message: string, code: StrataErrorCode) {
    super(message);
    this.code = code;
  }
}

const DefaultConnectApiHost = "https://connect.connectstrata.com";
const OAuthAuthorizePath = "/oauth/authorize";
const OAuthTimeoutMs = 600000; // 10 minutes
const DetectClosedAuthWindowDisabledProviders = ["shopify"];

/**
 * @interface StrataOptions - Configuration options for the Strata SDK
 */
export type StrataOptions = {
  /** The Strata Connect API host URL. Defaults to sandbox environment if not provided */
  connectApiHost?: string;
  /** Enables debug logging when set to true */
  debug?: boolean;
};

/**
 * @interface AuthorizeOptions - Options for the authorize method
 */
export interface AuthorizeOptions {
  /** Additional parameters for the server to use when setting up the connection */
  customParams?: Record<string, unknown>;
  /**
   * Detect if the user closes the auth window.
   *
   * Detection will not work for providers that set the `Cross-Origin-Opener-Policy` header
   * to `same-origin`. Strata has pre-emptively disabled detection for providers that
   * are known to use a strict COOP value.
   * @default true
   */
  detectClosedAuthWindow?: boolean;
}

/**
 * @class Strata - The Strata Frontend SDK
 */
export default class Strata {
  private connectApiBaseUrl: URL;
  private debug: boolean;
  private width: number = 600;
  private height: number = 700;
  private oauthWindow: OAuthWindow | null = null;
  private messageListener: ((event: MessageEvent) => void) | null = null;

  /**
   * Creates a new instance of the Strata SDK
   * @param options - Configuration options for the SDK
   * @throws {StrataError} If the connectApiHost is not a valid URL
   */
  constructor(options: StrataOptions = {}) {
    this.debug = options.debug || false;

    try {
      this.connectApiBaseUrl = new URL(
        options.connectApiHost || DefaultConnectApiHost,
      );
    } catch {
      throw new StrataError(
        "The connectApiHost provided is not a valid URL",
        SdkErrorCode.InvalidConnectApiHost,
      );
    }
  }

  /**
   * Authorize an integration for a user
   * @param jwtToken - A signed user JWT token
   * @param serviceProviderId - The service provider id
   * @param options - Optional parameters for the authorization flow
   * @returns Promise that resolves when the OAuth flow completes
   * @throws {StrataError} If the popup is blocked, the user closes the window, or authorization fails
   * @example
   * ```typescript
   * try {
   *   await strata.authorize('jwt-token', 'shopify', {
   *     customParams: { shop: 'my-shop.myshopify.com' }
   *   });
   *   console.log('Authorization successful');
   * } catch (error) {
   *   if (error instanceof StrataError) {
   *     console.error(`Authorization failed: ${error.code}`);
   *   }
   * }
   * ```
   */
  public authorize(
    jwtToken: string,
    serviceProviderId: string,
    options?: AuthorizeOptions,
  ): Promise<string> {
    this.cleanup();

    this.validateAuthParams(serviceProviderId, options?.customParams || {});

    // https://www.ryanthomson.net/articles/you-shouldnt-call-window-open-asynchronously/
    // how to avoid browser blocking popup:
    // - open popup outside of async context
    // - open popup with a user click in the call stack
    const layout = OAuthWindow.getLayout({
      width: this.width,
      height: this.height,
    });

    const authorizeUrl = new URL(OAuthAuthorizePath, this.connectApiBaseUrl);
    authorizeUrl.searchParams.append("serviceProviderId", serviceProviderId);
    authorizeUrl.searchParams.append("token", jwtToken);

    if (options?.customParams) {
      Object.entries(options.customParams).forEach(([k, v]) =>
        authorizeUrl.searchParams.append(k, String(v)),
      );
    }

    this.logDebug("opening authorize url:", authorizeUrl.href);

    const popup = window.open(
      authorizeUrl.href,
      "_blank",
      `width=${layout.width},height=${layout.height},left=${layout.left},top=${layout.top}`,
    );

    return new Promise((resolve, reject) => {
      if (popup && !popup.closed) {
        this.oauthWindow = new OAuthWindow({ window: popup });
      } else {
        reject(
          new StrataError(
            "Unable to open auth window",
            SdkErrorCode.PopupBlocked,
          ),
        );
      }

      this.messageListener = (event: MessageEvent) => {
        if (
          event.source !== popup ||
          event.origin !== this.connectApiBaseUrl.origin
        ) {
          return;
        }

        this.logDebug("received message from auth window", event);

        if (!this.isOAuthResult(event.data)) {
          this.logDebug(
            "received invalid message from auth window",
            event.data,
          );
          this.cleanup(false);
          return;
        }

        if (event.data.status === "Success") {
          this.logDebug("authentication successful");
          this.cleanup();
          resolve(event.data.connectionId);
          return;
        }

        this.logDebug("authentication failed");
        this.cleanup(false);
        reject(new StrataError("Authorization failed", event.data.code));
      };

      window.addEventListener("message", this.messageListener);

      const detectClosed =
        options?.detectClosedAuthWindow ??
        !DetectClosedAuthWindowDisabledProviders.includes(serviceProviderId);
      if (detectClosed) {
        const checkPopupClosed = setInterval(() => {
          if (!this.oauthWindow || !this.oauthWindow.isOpen()) {
            this.logDebug("auth window closed");
            clearInterval(checkPopupClosed);
            this.cleanup();
            reject(
              new StrataError("Authorization failed", SdkErrorCode.PopupClosed),
            );
          }
        }, 500);
      }

      setTimeout(() => {
        this.logDebug("authorization timed out");
        this.cleanup();
        reject(
          new StrataError(
            "Authorization timed out",
            SdkErrorCode.AuthFlowTimeout,
          ),
        );
      }, OAuthTimeoutMs);
    });
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private logDebug(...args: any[]) {
    if (this.debug) {
      console.log(...args);
    }
  }

  private validateAuthParams(
    serviceProviderId: string,
    customParams: Record<string, unknown>,
  ): void {
    if (serviceProviderId === "shopify") {
      this.validateShopifyAuthParams(customParams);
    }
  }

  private validateShopifyAuthParams(
    customParams: Record<string, unknown>,
  ): void {
    if (!customParams?.shop) {
      throw new StrataError(
        "Shopify authorization requires a 'shop' property containing the merchant shop domain. For example: 'connectstrata.myshopify.com'",
        SdkErrorCode.InvalidAuthParams,
      );
    }
  }

  /**
   * Check if an event received by the window listener is an OAuthResult
   * @internal
   */
  private isOAuthResult(data: unknown): data is OAuthResult {
    if (typeof data !== "object" || data === null || !("status" in data)) {
      return false;
    }
    const obj = data as Record<string, unknown>;
    if (obj.status === "Success") {
      return typeof obj.connectionId === "string";
    }
    if (obj.status === "Error") {
      return typeof obj.code === "string";
    }
    return false;
  }

  /**
   * Cleans up resources used by the OAuth flow
   * @internal
   * @param closeWindow - Whether to close the popup window
   */
  private cleanup(closeWindow: boolean = true) {
    if (closeWindow) {
      this.oauthWindow?.close();
    }

    this.oauthWindow = null;

    if (this.messageListener) {
      window.removeEventListener("message", this.messageListener);
      this.messageListener = null;
    }
  }
}
